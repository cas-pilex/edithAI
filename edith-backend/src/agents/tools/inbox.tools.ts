import { toolRegistry, createTool, DEFAULT_APPROVAL_CATEGORIES } from './index.js';
import type { EnhancedAgentContext, ToolHandlerResult, ToolPropertySchema } from '../../types/agent.types.js';
import { prisma } from '../../database/client.js';
import { logger } from '../../utils/logger.js';

// ==================== TOOL HANDLERS ====================

async function handleCategorizeEmail(
  input: Record<string, unknown>,
  context: EnhancedAgentContext
): Promise<ToolHandlerResult> {
  const { emailId, category, priorityScore, reasoning } = input as {
    emailId: string;
    category: string;
    priorityScore: number;
    reasoning?: string;
  };

  try {
    const email = await prisma.email.update({
      where: { id: emailId, userId: context.userId },
      data: {
        category: category as 'URGENT' | 'ACTION_REQUIRED' | 'FOLLOW_UP' | 'FYI' | 'NEWSLETTER' | 'SPAM',
        priorityScore,
        processingStatus: 'COMPLETED',
        processedAt: new Date(),
      },
    });

    return {
      success: true,
      data: {
        emailId: email.id,
        category: email.category,
        priorityScore: email.priorityScore,
        reasoning,
      },
    };
  } catch (error) {
    logger.error('Failed to categorize email', { error, emailId });
    return {
      success: false,
      error: `Failed to categorize email: ${error instanceof Error ? error.message : 'Unknown error'}`,
    };
  }
}

async function handleSummarizeEmail(
  input: Record<string, unknown>,
  context: EnhancedAgentContext
): Promise<ToolHandlerResult> {
  const { emailId } = input as { emailId: string };

  try {
    const email = await prisma.email.findUnique({
      where: { id: emailId, userId: context.userId },
    });

    if (!email) {
      return { success: false, error: 'Email not found' };
    }

    // The actual summary will be generated by the agent and passed back
    // This handler just returns the email content for the agent to summarize
    return {
      success: true,
      data: {
        emailId: email.id,
        subject: email.subject,
        from: email.fromAddress,
        bodyText: email.bodyText?.substring(0, 5000), // Limit for context
        receivedAt: email.receivedAt,
      },
    };
  } catch (error) {
    logger.error('Failed to get email for summary', { error, emailId });
    return {
      success: false,
      error: `Failed to get email: ${error instanceof Error ? error.message : 'Unknown error'}`,
    };
  }
}

async function handleDraftReply(
  input: Record<string, unknown>,
  context: EnhancedAgentContext
): Promise<ToolHandlerResult> {
  const { emailId, subject, body, tone } = input as {
    emailId: string;
    subject?: string;
    body: string;
    tone?: string;
  };

  try {
    const originalEmail = await prisma.email.findUnique({
      where: { id: emailId, userId: context.userId },
    });

    if (!originalEmail) {
      return { success: false, error: 'Original email not found' };
    }

    const draft = await prisma.emailDraft.create({
      data: {
        userId: context.userId,
        emailId,
        toAddresses: [originalEmail.fromAddress],
        ccAddresses: [],
        subject: subject || `Re: ${originalEmail.subject}`,
        body,
        tone,
        status: 'DRAFT',
      },
    });

    return {
      success: true,
      data: {
        draftId: draft.id,
        to: draft.toAddresses,
        subject: draft.subject,
        body: draft.body,
        status: draft.status,
      },
    };
  } catch (error) {
    logger.error('Failed to create draft reply', { error, emailId });
    return {
      success: false,
      error: `Failed to create draft: ${error instanceof Error ? error.message : 'Unknown error'}`,
    };
  }
}

async function handleExtractActionItems(
  input: Record<string, unknown>,
  context: EnhancedAgentContext
): Promise<ToolHandlerResult> {
  const { emailId } = input as { emailId: string };

  try {
    const email = await prisma.email.findUnique({
      where: { id: emailId, userId: context.userId },
    });

    if (!email) {
      return { success: false, error: 'Email not found' };
    }

    // Return email content for the agent to extract action items
    return {
      success: true,
      data: {
        emailId: email.id,
        subject: email.subject,
        from: email.fromAddress,
        bodyText: email.bodyText?.substring(0, 5000),
        existingTasks: email.extractedTasks,
        existingDates: email.extractedDates,
      },
    };
  } catch (error) {
    logger.error('Failed to get email for action extraction', { error, emailId });
    return {
      success: false,
      error: `Failed to get email: ${error instanceof Error ? error.message : 'Unknown error'}`,
    };
  }
}

async function handleSendEmail(
  input: Record<string, unknown>,
  _context: EnhancedAgentContext
): Promise<ToolHandlerResult> {
  const { draftId, to, cc, subject, body } = input as {
    draftId?: string;
    to?: string[];
    cc?: string[];
    subject?: string;
    body?: string;
  };

  // This action requires approval
  return {
    success: true,
    requiresApproval: true,
    approvalDetails: {
      proposedAction: { draftId, to, cc, subject, body },
      reasoning: 'Sending email requires user approval',
      impact: {
        type: 'MEDIUM',
        affectedAreas: ['email', 'external_communication'],
        affectedContacts: to,
      },
      isReversible: false,
      relatedEntities: draftId ? [{ type: 'email', id: draftId, displayName: subject || 'Draft' }] : [],
    },
    data: {
      message: 'Email send requires approval',
      draftId,
      to,
      subject,
    },
  };
}

async function handleArchiveEmails(
  input: Record<string, unknown>,
  context: EnhancedAgentContext
): Promise<ToolHandlerResult> {
  const { emailIds } = input as { emailIds: string[] };

  try {
    // Archive locally in DB
    const result = await prisma.email.updateMany({
      where: {
        id: { in: emailIds },
        userId: context.userId,
      },
      data: { isArchived: true },
    });

    // Also archive in Gmail if connected
    try {
      const { createGmailClientForUser } = await import('../../integrations/google/GmailClient.js');
      const gmail = await createGmailClientForUser(context.userId);
      if (gmail) {
        // Get external IDs for Gmail API
        const emails = await prisma.email.findMany({
          where: { id: { in: emailIds }, userId: context.userId },
          select: { externalId: true },
        });
        const gmailIds = emails.map((e) => e.externalId).filter(Boolean);
        if (gmailIds.length > 0) {
          await gmail.archiveMessages(gmailIds);
        }
      }
    } catch (syncError) {
      logger.warn('Failed to archive in Gmail (archived locally)', { error: syncError });
    }

    return {
      success: true,
      data: {
        archivedCount: result.count,
        emailIds,
      },
    };
  } catch (error) {
    logger.error('Failed to archive emails', { error, emailIds });
    return {
      success: false,
      error: `Failed to archive emails: ${error instanceof Error ? error.message : 'Unknown error'}`,
    };
  }
}

async function handleSearchEmails(
  input: Record<string, unknown>,
  context: EnhancedAgentContext
): Promise<ToolHandlerResult> {
  const { query, from, to, category, dateRange, limit = 20 } = input as {
    query?: string;
    from?: string;
    to?: string;
    category?: string;
    dateRange?: { start: string; end: string };
    limit?: number;
  };

  try {
    const where: Record<string, unknown> = { userId: context.userId, isDeleted: false };

    if (from) where.fromAddress = { contains: from, mode: 'insensitive' };
    if (category) where.category = category;
    if (dateRange) {
      where.receivedAt = {
        gte: new Date(dateRange.start),
        lte: new Date(dateRange.end),
      };
    }
    if (query) {
      where.OR = [
        { subject: { contains: query, mode: 'insensitive' } },
        { bodyText: { contains: query, mode: 'insensitive' } },
      ];
    }

    const emails = await prisma.email.findMany({
      where: where as { userId: string; isDeleted: boolean; [key: string]: unknown },
      take: Math.min(limit, 50),
      orderBy: { receivedAt: 'desc' },
      select: {
        id: true,
        subject: true,
        fromAddress: true,
        fromName: true,
        receivedAt: true,
        category: true,
        priorityScore: true,
        snippet: true,
        isRead: true,
      },
    });

    return {
      success: true,
      data: {
        emails,
        count: emails.length,
        query: { query, from, to, category, dateRange },
      },
    };
  } catch (error) {
    logger.error('Failed to search emails', { error });
    return {
      success: false,
      error: `Failed to search emails: ${error instanceof Error ? error.message : 'Unknown error'}`,
    };
  }
}

async function handleSetFollowUpReminder(
  input: Record<string, unknown>,
  context: EnhancedAgentContext
): Promise<ToolHandlerResult> {
  const { emailId, reminderDate, reason } = input as {
    emailId: string;
    reminderDate: string;
    reason?: string;
  };

  try {
    // Create a notification for the follow-up
    const notification = await prisma.notification.create({
      data: {
        userId: context.userId,
        type: 'EMAIL_FOLLOW_UP',
        title: 'Email Follow-up Reminder',
        body: reason || 'Follow up on this email',
        data: { emailId, reason },
        channel: 'IN_APP',
        priority: 'NORMAL',
        scheduledFor: new Date(reminderDate),
        status: 'PENDING',
      },
    });

    return {
      success: true,
      data: {
        notificationId: notification.id,
        emailId,
        scheduledFor: notification.scheduledFor,
        reason,
      },
    };
  } catch (error) {
    logger.error('Failed to set follow-up reminder', { error, emailId });
    return {
      success: false,
      error: `Failed to set reminder: ${error instanceof Error ? error.message : 'Unknown error'}`,
    };
  }
}

async function handleUpdateSenderImportance(
  input: Record<string, unknown>,
  context: EnhancedAgentContext
): Promise<ToolHandlerResult> {
  const { email, importanceScore } = input as {
    email: string;
    importanceScore: number;
  };

  try {
    // Find or create contact
    let contact = await prisma.contact.findFirst({
      where: { userId: context.userId, email },
    });

    if (contact) {
      contact = await prisma.contact.update({
        where: { id: contact.id },
        data: { importanceScore: Math.min(10, Math.max(1, importanceScore)) },
      });
    } else {
      contact = await prisma.contact.create({
        data: {
          userId: context.userId,
          email,
          importanceScore: Math.min(10, Math.max(1, importanceScore)),
          source: 'EMAIL',
          relationshipType: 'OTHER',
        },
      });
    }

    return {
      success: true,
      data: {
        contactId: contact.id,
        email: contact.email,
        importanceScore: contact.importanceScore,
      },
    };
  } catch (error) {
    logger.error('Failed to update sender importance', { error, email });
    return {
      success: false,
      error: `Failed to update importance: ${error instanceof Error ? error.message : 'Unknown error'}`,
    };
  }
}

// ==================== TOOL DEFINITIONS ====================

const emailIdProperty: ToolPropertySchema = {
  type: 'string',
  description: 'The unique ID of the email',
};

const categoryProperty: ToolPropertySchema = {
  type: 'string',
  description: 'Email category',
  enum: ['URGENT', 'ACTION_REQUIRED', 'FOLLOW_UP', 'FYI', 'NEWSLETTER', 'SPAM'],
};

/**
 * Register all inbox tools with the global registry
 */
export function registerInboxTools(): void {
  // Categorize Email
  toolRegistry.register(
    createTool(
      'categorize_email',
      'Categorize an email into priority buckets with a priority score (0-100)',
      {
        emailId: emailIdProperty,
        category: categoryProperty,
        priorityScore: {
          type: 'number',
          description: 'Priority score from 0-100 based on urgency and importance',
        },
        reasoning: {
          type: 'string',
          description: 'Brief explanation for the categorization',
        },
      },
      ['emailId', 'category', 'priorityScore'],
      'inbox',
      handleCategorizeEmail,
      { approvalCategory: DEFAULT_APPROVAL_CATEGORIES['categorize_email'] }
    )
  );

  // Summarize Email
  toolRegistry.register(
    createTool(
      'summarize_email',
      'Generate a concise summary of an email, extracting key points and action items',
      {
        emailId: emailIdProperty,
      },
      ['emailId'],
      'inbox',
      handleSummarizeEmail,
      { approvalCategory: DEFAULT_APPROVAL_CATEGORIES['summarize_email'] }
    )
  );

  // Draft Reply
  toolRegistry.register(
    createTool(
      'draft_reply',
      'Create a draft reply to an email with specified tone and key points',
      {
        emailId: emailIdProperty,
        body: {
          type: 'string',
          description: 'The body content of the reply',
        },
        subject: {
          type: 'string',
          description: 'Optional subject override (defaults to Re: original subject)',
        },
        tone: {
          type: 'string',
          description: 'The tone of the reply',
          enum: ['FORMAL', 'CASUAL', 'MIXED'],
        },
      },
      ['emailId', 'body'],
      'inbox',
      handleDraftReply,
      { approvalCategory: DEFAULT_APPROVAL_CATEGORIES['draft_reply'] }
    )
  );

  // Extract Action Items
  toolRegistry.register(
    createTool(
      'extract_action_items',
      'Extract tasks, deadlines, and dates mentioned in an email',
      {
        emailId: emailIdProperty,
      },
      ['emailId'],
      'inbox',
      handleExtractActionItems,
      { approvalCategory: DEFAULT_APPROVAL_CATEGORIES['extract_action_items'] }
    )
  );

  // Send Email
  toolRegistry.register(
    createTool(
      'send_email',
      'Send an email (either from a draft or compose new). Requires user approval.',
      {
        draftId: {
          type: 'string',
          description: 'ID of an existing draft to send',
        },
        to: {
          type: 'array',
          items: { type: 'string' },
          description: 'Recipient email addresses (for new emails)',
        },
        cc: {
          type: 'array',
          items: { type: 'string' },
          description: 'CC email addresses',
        },
        subject: {
          type: 'string',
          description: 'Email subject (for new emails)',
        },
        body: {
          type: 'string',
          description: 'Email body (for new emails)',
        },
      },
      [],
      'inbox',
      handleSendEmail,
      { requiresApproval: true, approvalCategory: DEFAULT_APPROVAL_CATEGORIES['send_email'] }
    )
  );

  // Archive Emails
  toolRegistry.register(
    createTool(
      'archive_emails',
      'Archive one or more emails',
      {
        emailIds: {
          type: 'array',
          items: { type: 'string' },
          description: 'IDs of emails to archive',
        },
      },
      ['emailIds'],
      'inbox',
      handleArchiveEmails,
      { approvalCategory: DEFAULT_APPROVAL_CATEGORIES['archive_emails'] }
    )
  );

  // Search Emails
  toolRegistry.register(
    createTool(
      'search_emails',
      'Search emails by various criteria',
      {
        query: {
          type: 'string',
          description: 'Text to search in subject and body',
        },
        from: {
          type: 'string',
          description: 'Filter by sender email address',
        },
        to: {
          type: 'string',
          description: 'Filter by recipient email address',
        },
        category: categoryProperty,
        dateRange: {
          type: 'object',
          description: 'Date range filter',
          properties: {
            start: { type: 'string', description: 'Start date (ISO format)' },
            end: { type: 'string', description: 'End date (ISO format)' },
          },
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results (default 20, max 50)',
        },
      },
      [],
      'inbox',
      handleSearchEmails,
      { approvalCategory: DEFAULT_APPROVAL_CATEGORIES['search_emails'] }
    )
  );

  // Set Follow-up Reminder
  toolRegistry.register(
    createTool(
      'set_follow_up_reminder',
      'Schedule a reminder to follow up on an email',
      {
        emailId: emailIdProperty,
        reminderDate: {
          type: 'string',
          description: 'When to remind (ISO date string)',
        },
        reason: {
          type: 'string',
          description: 'Reason for the follow-up',
        },
      },
      ['emailId', 'reminderDate'],
      'inbox',
      handleSetFollowUpReminder,
      { approvalCategory: DEFAULT_APPROVAL_CATEGORIES['set_follow_up_reminder'] }
    )
  );

  // Update Sender Importance
  toolRegistry.register(
    createTool(
      'update_sender_importance',
      'Update the importance score for a sender/contact',
      {
        email: {
          type: 'string',
          description: 'The email address of the sender',
        },
        importanceScore: {
          type: 'number',
          description: 'Importance score from 1-10',
        },
      },
      ['email', 'importanceScore'],
      'inbox',
      handleUpdateSenderImportance,
      { approvalCategory: DEFAULT_APPROVAL_CATEGORIES['update_sender_importance'] }
    )
  );

  logger.info('Inbox tools registered', { count: 9 });
}
